/**
 * Smart Manager APILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiResponse, RequestOptions } from '../core';
import { ValidateErrorJSONError } from '../errors/validateErrorJSONError';
import {
  CaptureLogsBody,
  captureLogsBodySchema,
} from '../models/captureLogsBody';
import {
  CaptureLogsStatus,
  captureLogsStatusSchema,
} from '../models/captureLogsStatus';
import {
  SmartManagerAbout,
  smartManagerAboutSchema,
} from '../models/smartManagerAbout';
import {
  SmartManagerConfig,
  smartManagerConfigSchema,
} from '../models/smartManagerConfig';
import { Template, templateSchema } from '../models/template';
import { array, unknown } from '../schema';
import { BaseController } from './baseController';

export class ConfigController extends BaseController {
  /**
   * Get the current config for this Smart Manager
   *
   * @return Response from the API call
   */
  async getConfig(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SmartManagerConfig>> {
    const req = this.createRequest('GET', '/config');
    req.authenticate(false);
    return req.callAsJson(smartManagerConfigSchema, requestOptions);
  }

  /**
   * Create or replace an existing config for this Smart Manager
   *
   * @param body
   * @return Response from the API call
   */
  async updateConfig(
    body: SmartManagerConfig,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SmartManagerConfig>> {
    const req = this.createRequest('PUT', '/config');
    const mapped = req.prepareArgs({ body: [body, smartManagerConfigSchema] });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.throwOn(422, ValidateErrorJSONError, 'Validation Failed');
    req.authenticate(false);
    return req.callAsJson(smartManagerConfigSchema, requestOptions);
  }

  /**
   * Get a summary report for this Smart Manager and the environment it's running in
   *
   * @return Response from the API call
   */
  async getManagerAbout(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SmartManagerAbout>> {
    const req = this.createRequest('GET', '/config/about');
    req.authenticate(false);
    return req.callAsJson(smartManagerAboutSchema, requestOptions);
  }

  /**
   * Get the Smart Manager network device name
   *
   * @return Response from the API call
   */
  async getSmartManagerName(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<string>> {
    const req = this.createRequest('GET', '/config/device-name');
    req.authenticate(false);
    return req.callAsText(requestOptions);
  }

  /**
   * Get all available room templates for this Smart Manager
   *
   * @return Response from the API call
   */
  async getTemplates(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Template[]>> {
    const req = this.createRequest('GET', '/config/templates');
    req.authenticate(false);
    return req.callAsJson(array(templateSchema), requestOptions);
  }

  /**
   * Route for uploading new templates. This accept any object as input
   * so validation is not done by tsoa (results in ugly error messages)
   * and instead we do our own validation
   *
   * @param body
   * @return Response from the API call
   */
  async uploadTemplates(
    body: unknown[],
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Template[]>> {
    const req = this.createRequest('POST', '/config/templates');
    const mapped = req.prepareArgs({ body: [body, array(unknown())] });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.authenticate(false);
    return req.callAsJson(array(templateSchema), requestOptions);
  }

  /**
   * Get log capture status
   *
   * @return Response from the API call
   */
  async getStreamingLogsStatus(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<CaptureLogsStatus>> {
    const req = this.createRequest('GET', '/config/logs/capture');
    req.authenticate(false);
    return req.callAsJson(captureLogsStatusSchema, requestOptions);
  }

  /**
   * Starts or stops streaming logs over websocket
   *
   * @param body
   * @return Response from the API call
   */
  async captureLogs(
    body: CaptureLogsBody,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<CaptureLogsStatus>> {
    const req = this.createRequest('POST', '/config/logs/capture');
    const mapped = req.prepareArgs({ body: [body, captureLogsBodySchema] });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.authenticate(false);
    return req.callAsJson(captureLogsStatusSchema, requestOptions);
  }
}
