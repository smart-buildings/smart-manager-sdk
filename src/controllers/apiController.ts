/**
 * Smart Manager APILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiResponse, RequestOptions } from '../core';
import { DaliScan400Error } from '../errors/daliScan400Error';
import { DaliScan503Error } from '../errors/daliScan503Error';
import {
  ConfigTemplatesCreateRequest,
  configTemplatesCreateRequestSchema,
} from '../models/configTemplatesCreateRequest';
import {
  ConfigTemplatesCreateResponse,
  configTemplatesCreateResponseSchema,
} from '../models/configTemplatesCreateResponse';
import { ScanResponse, scanResponseSchema } from '../models/scanResponse';
import { optional, string } from '../schema';
import { BaseController } from './baseController';

export class ApiController extends BaseController {
  /**
   * Deletes a particular device from a template
   *
   * @param templateId
   * @param deviceId
   * @return Response from the API call
   */
  async deleteTemplateDevice(
    templateId: string,
    deviceId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      templateId: [templateId, string()],
      deviceId: [deviceId, string()],
    });
    req.appendTemplatePath`/config/templates/${mapped.templateId}/devices/${mapped.deviceId}`;
    return req.call(requestOptions);
  }

  /**
   * Create a template from scanned peripherals
   *
   * @param body         Array of scanned peripherals
   * @return Response from the API call
   */
  async postConfigTemplateCreate(
    body?: ConfigTemplatesCreateRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ConfigTemplatesCreateResponse>> {
    const req = this.createRequest('POST', '/config/templates/create');
    const mapped = req.prepareArgs({
      body: [body, optional(configTemplatesCreateRequestSchema)],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    return req.callAsJson(configTemplatesCreateResponseSchema, requestOptions);
  }

  /**
   * Starts a scan for peripherals currently linked to the smart manager.
   *
   * If a dali module is present, the smart manager will check the peripherals table (in the DB) to
   * determine whether dali lights already exist (from being commissioned previously).
   *
   * The smart manager will send a response that let's the front-end know if there is a dali module in
   * the network and any dali lights it currently has saved.
   *
   * The front-end will use the results of this request to determine whether it needs to send a seperate
   * request to rescan for dali lights using the `GET /{multisense_ID}/dali-scan` endpoint.
   *
   * If the network has a dali controller but the `scannedPeripheralsArray` returned from this endpoint
   * doesnt contain any peripherals with a className of `DaliLight`, the rescan should be triggered
   *
   *
   *
   *
   * @return Response from the API call
   */
  async getPeripherals(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ScanResponse>> {
    const req = this.createRequest('GET', '/scan');
    return req.callAsJson(scanResponseSchema, requestOptions);
  }

  /**
   * Endpoint for manually triggering the re-addressing of dali lights connecting via a particual
   * multisense
   *
   * Once the smart manager has completed the dali scan, the results will be made available via
   * websockets
   *
   * @param multisenseId id of the multisense that has the dali module
   * @return Response from the API call
   */
  async getMultisenseIDDaliScan(
    multisenseId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ multisenseId: [multisenseId, string()] });
    req.appendTemplatePath`/dali/scan/${mapped.multisenseId}`;
    req.throwOn(400, DaliScan400Error, 'Bad Request');
    req.throwOn(503, DaliScan503Error, 'Service Unavailable');
    return req.call(requestOptions);
  }
}
